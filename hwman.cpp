
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.47
 */


/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using template emitter:
 *      SOM Emitter emitxtm: 2.23.1.9
 */

#ifndef SOM_Module_hwman_Source
#define SOM_Module_hwman_Source
#endif

#define WPHwManagerEx_Class_Source
#define M_WPHwManagerEx_Class_Source

#define _RETAIL /* to completely eliminate the ...MethodDebug(...) debugging output to SOMOutCharRoutine (default:stdout) */
#include "hwman.xih"

SOMEXTERN VOID SOMLINK SOMInitModule(long majorVersion,long minorVersion, string className)
{
    SOM_IgnoreWarning(majorVersion);
    SOM_IgnoreWarning(minorVersion);
    SOM_IgnoreWarning(className);
    WPHwManagerExNewClass(WPHwManagerEx_MajorVersion,WPHwManagerEx_MinorVersion);
    return;
}

SOM_Scope void SOMLINK somDefaultInit(WPHwManagerEx *somSelf,
                                      som3InitCtrl* ctrl)
{
    WPHwManagerExData *somThis; /* set in BeginInitializer */
    somInitCtrl globalCtrl;
    somBooleanVector myMask;
    WPHwManagerExMethodDebug("WPHwManagerEx","somDefaultInit");
    WPHwManagerEx_BeginInitializer_somDefaultInit;

    WPHwManagerEx_Init_WPHwManager_somDefaultInit(somSelf, ctrl);

    /*
     * local WPHwManagerEx initialization code added by programmer
     */
}


SOM_Scope void SOMLINK somDestruct(WPHwManagerEx *somSelf, octet doFree,
                                   som3DestructCtrl* ctrl)
{
    WPHwManagerExData *somThis; /* set in BeginDestructor */
    somDestructCtrl globalCtrl;
    somBooleanVector myMask;
    WPHwManagerExMethodDebug("WPHwManagerEx","somDestruct");
    WPHwManagerEx_BeginDestructor;

    /*
     * local WPHwManagerEx deinitialization code added by programmer
     */

    WPHwManagerEx_EndDestructor;
}

char buf[8192];

SOM_Scope BOOL  SOMLINK wpPopulate(WPHwManagerEx *somSelf, ULONG ulReserved,
                                   PSZ pszPath, BOOL fFoldersOnly)
{
    /* WPHwManagerExData *somThis = WPHwManagerExGetData(somSelf); */
    WPHwManagerExMethodDebug("WPHwManagerEx","wpPopulate");

    if (WPHwManagerEx_parent_WPHwManager_wpPopulate(somSelf,
                                                        ulReserved,
                                                        pszPath,
                                                        fFoldersOnly)) {
        HANDLELIST Handles;

        WPDevice *NextObj,*Obj;
        PFN_GETUNIQUEID wpGetUniqueID;
        PFN_GETNODEBASETYPE wpGetNodeBaseType;

        PFN_WPREQUESTFOLDERMUTEXSEM wpRequestFolderMutexSem;
        PFN_WPRELEASEFOLDERMUTEXSEM wpReleaseFolderMutexSem;

        RMHANDLE rmHandle;
        APIRET rc;

        RM_ENUMNODES_PARM p;
        PRM_ENUMNODES_DATA d=(PRM_ENUMNODES_DATA)buf;
        ULONG i;

        HPOINTER hWPDevBusPointer;

        // these functions are not being made available via IDL
        // resolve function address by name
        wpRequestFolderMutexSem = (PFN_WPREQUESTFOLDERMUTEXSEM)somResolveByName(somSelf,"wpRequestFolderMutexSem");
        wpReleaseFolderMutexSem = (PFN_WPRELEASEFOLDERMUTEXSEM)somResolveByName(somSelf,"wpReleaseFolderMutexSem");

        if (somSelf->wpQueryFldrFlags() & FOI_POPULATEDWITHALL) {

           if (wpRequestFolderMutexSem(somSelf,1000) == NO_ERROR) {
               // get the default icon for the WPDevBus device object
               hWPDevBusPointer = _WPDevBus->wpclsQueryIcon();

               // query the complete RM tree: it's kind of inefficient to subsequently
               // compare every single object with every single node of the tree
               // but I can see no other way without rewriting the whole HWManager
               // class ...
               // add. info: I tried "RMGetNodeInfo" and also "RMHandleToResourceHandleList"
               // from RMINFO.DLL in order to detect invalid nodes but "RMGetNodeInfo" will
               // lead to a Trap 3 in RESOURCE.SYS for an invalid node and
               // "RMHandleToResourceHandleList" will return with RMRC_SUCCESS even for an invalid
               // node, oh well ...
               p.Command = RM_COMMAND_PHYS; 
               memset(d,0,sizeof(buf));
               rc = RMEnumNodes(&p,d,sizeof(buf));

               if (rc == RMRC_SUCCESS) {
                  Obj = (WPDevice*)somSelf->wpQueryContent(NULL,QC_FIRST);
                  if (somIsObj(Obj)) {
                      // this function is not being made available via IDL
                      // resolve function address by name
                      wpGetUniqueID = (PFN_GETUNIQUEID)somResolveByName(Obj,"wpGetUniqueID");
                      // this function is not being made available via IDL
                      // resolve function address by name
                      wpGetNodeBaseType = (PFN_GETNODEBASETYPE)somResolveByName(Obj,"wpGetNodeBaseType");
   
                      while(Obj) {
                          NextObj = (WPDevice *)somSelf->wpQueryContent(Obj,QC_NEXT);

                          // for bus devices (like Veit Kannegieser's PCIBUS.SNP additions for the AGP bus)
                          // reset the icon to the icon of the WPDevBus device Object
                          if (wpGetNodeBaseType(Obj) == AS_BASE_BRIDGE) {
                             Obj->wpSetIcon(hWPDevBusPointer);
                          } /* endif */
      
                          // here we compare the RMHandle of the current object with every handle
                          // in the RMHandle tree, if we cannot find it in the RMHandle tree
                          // then this object is no longer valid/relevant
                          rmHandle = wpGetUniqueID(Obj);     // RM Handle
                          for (i=0;i<d->NumEntries ;i++) {
                             if (rmHandle == d->NodeEntry[i].RMHandle) {
                                break;
                             } /* endif */
                          } /* endfor */
                          if (i>=d->NumEntries) { // this is an invalid handle, remove the object
                             Obj->wpFree();
                          }
                          else {                  // this is a valid handle, just unlock the object
                             Obj->wpUnlockObject();
                          } /* endif */
                          Obj = NextObj;
                      }
                  }
               }
               wpReleaseFolderMutexSem(somSelf);
           }
        }
        return TRUE;
    }

    return FALSE;
}


SOM_Scope ULONG  SOMLINK wpclsQueryStyle(M_WPHwManagerEx *somSelf)
{
    ULONG ret;

    /* M_WPHwManagerExData *somThis = M_WPHwManagerExGetData(somSelf); */
    M_WPHwManagerExMethodDebug("M_WPHwManagerEx","wpclsQueryStyle");

    ret =  (M_WPHwManagerEx_parent_M_WPHwManager_wpclsQueryStyle(somSelf));
    ret |= CLSSTYLE_DONTTEMPLATE;
    return ret;
}

SOM_Scope PSZ  SOMLINK wpclsQueryTitle(M_WPHwManagerEx *somSelf)
{
    /* M_WPHwManagerExData *somThis = M_WPHwManagerExGetData(somSelf); */
    M_WPHwManagerExMethodDebug("M_WPHwManagerEx","wpclsQueryTitle");

    return "Hardware Manager Extension";
}
      
